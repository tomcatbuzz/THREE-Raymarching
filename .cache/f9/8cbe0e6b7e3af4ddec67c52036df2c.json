{"id":"js/shader/fragment.glsl","dependencies":[{"name":"C:\\Apache24\\htdocs\\THREE-Raymarching\\package.json","includedInParent":true,"mtime":1609368354121}],"generated":{"js":"module.exports = \"#define GLSLIFY 1\\nuniform float time;\\nuniform float progress;\\nuniform sampler2D matcap,matcap1;\\nuniform vec4 resolution;\\nvarying vec2 vUv;\\n// varying vec3 vPosition;\\nfloat PI = 3.141592653589793238;\\n\\n// matcap formula\\nvec2 getmatcap(vec3 eye, vec3 normal) {\\n  vec3 reflected = reflect(eye, normal);\\n  float m = 2.8284271247461903 * sqrt( reflected.z+1.0 );\\n  return reflected.xy / m + 0.5;\\n}\\n\\n// rotation\\nmat4 rotationMatrix(vec3 axis, float angle) {\\n    axis = normalize(axis);\\n    float s = sin(angle);\\n    float c = cos(angle);\\n    float oc = 1.0 - c;\\n    \\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\\n                0.0,                                0.0,                                0.0,                                1.0);\\n}\\n\\nvec3 rotate(vec3 v, vec3 axis, float angle) {\\n\\tmat4 m = rotationMatrix(axis, angle);\\n\\treturn (m * vec4(v, 1.0)).xyz;\\n}\\n\\n// move minimum\\nfloat smin( float a, float b, float k )\\n{\\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\\n    return mix( b, a, h ) - k*h*(1.0-h);\\n}\\n\\nfloat sdSphere( vec3 p, float r ){\\n  return length(p)-r;\\n}\\n\\nfloat sdBox( vec3 p, vec3 b )\\n{\\n  vec3 q = abs(p) - b;\\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\\n}\\n\\nfloat sdf(vec3 p){\\n\\tvec3 p1 = rotate(p,vec3(1.),time/5.);\\n\\tfloat box = sdBox(p1, vec3(0.3));\\n\\tfloat sphere = sdSphere(p,0.4);\\n\\treturn smin(box,sphere,0.1);\\n}\\n\\nvec3 calcNormal( in vec3 p ){ // for function f(p)\\nconst float eps = 0.0001; // or some other value\\nconst vec2 h = vec2(eps,0);\\nreturn normalize( vec3(sdf(p+h.xyy) - sdf(p-h.xyy),\\nsdf(p+h.yxy) - sdf(p-h.yxy),\\nsdf(p+h.yyx) - sdf(p-h.yyx) ) );\\n}\\n\\nvoid main()\\t{\\n\\tvec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);\\n\\tvec3 camPos = vec3(0.,0.,2.);\\n\\tvec3 ray = normalize(vec3((vUv - vec2(0.5))*resolution.zw,-1));\\n\\n\\tvec3 rayPos = camPos;\\n\\tfloat t = 0.;\\n\\tfloat tMax = 5.;\\n\\tfor(int i=0;i<256;++i){\\n\\t\\tvec3 pos = camPos + t*ray;\\n\\t\\tfloat h = sdf(pos);\\n\\t\\tif(h<0.0001 || t>tMax) break;\\n\\t\\tt+=h;\\n\\t}\\n\\n\\tvec3 color = vec3(0.);\\n\\tif(t<tMax){\\n\\t\\tvec3 pos = camPos + t*ray;\\n\\t\\tcolor = vec3(1.);\\n\\t\\tvec3 normal = calcNormal(pos);\\n\\t\\tcolor = normal;\\n\\t\\tfloat diff = dot(vec3(1.),normal);\\n\\t\\tvec2 matcapUV = getmatcap(ray,normal);\\n\\t\\tcolor = vec3(diff);\\n\\t\\tcolor = texture2D(matcap1,matcapUV).rgb;\\n\\t}\\n\\t\\n\\tgl_FragColor = vec4(color,1.);\\n}\";"},"sourceMaps":{"js":{"mappings":[{"name":"module","generated":{"line":1,"column":0},"source":"js/shader/fragment.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":6},"source":"js/shader/fragment.glsl","original":{"line":1,"column":6}},{"name":"exports","generated":{"line":1,"column":7},"source":"js/shader/fragment.glsl","original":{"line":1,"column":7}},{"generated":{"line":1,"column":14},"source":"js/shader/fragment.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":17},"source":"js/shader/fragment.glsl","original":{"line":1,"column":15}},{"generated":{"line":1,"column":2757},"source":"js/shader/fragment.glsl","original":{"line":1,"column":0}}],"sources":{"js/shader/fragment.glsl":"module.exports=\"#define GLSLIFY 1\\nuniform float time;\\nuniform float progress;\\nuniform sampler2D matcap,matcap1;\\nuniform vec4 resolution;\\nvarying vec2 vUv;\\n// varying vec3 vPosition;\\nfloat PI = 3.141592653589793238;\\n\\n// matcap formula\\nvec2 getmatcap(vec3 eye, vec3 normal) {\\n  vec3 reflected = reflect(eye, normal);\\n  float m = 2.8284271247461903 * sqrt( reflected.z+1.0 );\\n  return reflected.xy / m + 0.5;\\n}\\n\\n// rotation\\nmat4 rotationMatrix(vec3 axis, float angle) {\\n    axis = normalize(axis);\\n    float s = sin(angle);\\n    float c = cos(angle);\\n    float oc = 1.0 - c;\\n    \\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\\n                0.0,                                0.0,                                0.0,                                1.0);\\n}\\n\\nvec3 rotate(vec3 v, vec3 axis, float angle) {\\n\\tmat4 m = rotationMatrix(axis, angle);\\n\\treturn (m * vec4(v, 1.0)).xyz;\\n}\\n\\n// move minimum\\nfloat smin( float a, float b, float k )\\n{\\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\\n    return mix( b, a, h ) - k*h*(1.0-h);\\n}\\n\\nfloat sdSphere( vec3 p, float r ){\\n  return length(p)-r;\\n}\\n\\nfloat sdBox( vec3 p, vec3 b )\\n{\\n  vec3 q = abs(p) - b;\\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\\n}\\n\\nfloat sdf(vec3 p){\\n\\tvec3 p1 = rotate(p,vec3(1.),time/5.);\\n\\tfloat box = sdBox(p1, vec3(0.3));\\n\\tfloat sphere = sdSphere(p,0.4);\\n\\treturn smin(box,sphere,0.1);\\n}\\n\\nvec3 calcNormal( in vec3 p ){ // for function f(p)\\nconst float eps = 0.0001; // or some other value\\nconst vec2 h = vec2(eps,0);\\nreturn normalize( vec3(sdf(p+h.xyy) - sdf(p-h.xyy),\\nsdf(p+h.yxy) - sdf(p-h.yxy),\\nsdf(p+h.yyx) - sdf(p-h.yyx) ) );\\n}\\n\\nvoid main()\\t{\\n\\tvec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);\\n\\tvec3 camPos = vec3(0.,0.,2.);\\n\\tvec3 ray = normalize(vec3((vUv - vec2(0.5))*resolution.zw,-1));\\n\\n\\tvec3 rayPos = camPos;\\n\\tfloat t = 0.;\\n\\tfloat tMax = 5.;\\n\\tfor(int i=0;i<256;++i){\\n\\t\\tvec3 pos = camPos + t*ray;\\n\\t\\tfloat h = sdf(pos);\\n\\t\\tif(h<0.0001 || t>tMax) break;\\n\\t\\tt+=h;\\n\\t}\\n\\n\\tvec3 color = vec3(0.);\\n\\tif(t<tMax){\\n\\t\\tvec3 pos = camPos + t*ray;\\n\\t\\tcolor = vec3(1.);\\n\\t\\tvec3 normal = calcNormal(pos);\\n\\t\\tcolor = normal;\\n\\t\\tfloat diff = dot(vec3(1.),normal);\\n\\t\\tvec2 matcapUV = getmatcap(ray,normal);\\n\\t\\tcolor = vec3(diff);\\n\\t\\tcolor = texture2D(matcap1,matcapUV).rgb;\\n\\t}\\n\\t\\n\\tgl_FragColor = vec4(color,1.);\\n}\";"},"lineCount":null}},"error":null,"hash":"d65f6594fa7acde056ffd5216f5af548","cacheData":{"env":{}}}