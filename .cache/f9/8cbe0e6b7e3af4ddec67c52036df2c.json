{"id":"js/shader/fragment.glsl","dependencies":[{"name":"C:\\Apache24\\htdocs\\THREE-Raymarching\\package.json","includedInParent":true,"mtime":1609629985917}],"generated":{"js":"module.exports = \"#define GLSLIFY 1\\nuniform float time;\\nuniform float progress;\\nuniform vec2 mouse;\\nuniform sampler2D matcap,matcap1;\\nuniform vec4 resolution;\\nvarying vec2 vUv;\\n// varying vec3 vPosition;\\nfloat PI = 3.141592653589793238;\\n\\n// matcap formula\\nvec2 getmatcap(vec3 eye, vec3 normal) {\\n  vec3 reflected = reflect(eye, normal);\\n  float m = 2.8284271247461903 * sqrt( reflected.z+1.0 );\\n  return reflected.xy / m + 0.5;\\n}\\n\\n// rotation\\nmat4 rotationMatrix(vec3 axis, float angle) {\\n    axis = normalize(axis);\\n    float s = sin(angle);\\n    float c = cos(angle);\\n    float oc = 1.0 - c;\\n    \\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\\n                0.0,                                0.0,                                0.0,                                1.0);\\n}\\n\\nvec3 rotate(vec3 v, vec3 axis, float angle) {\\n\\tmat4 m = rotationMatrix(axis, angle);\\n\\treturn (m * vec4(v, 1.0)).xyz;\\n}\\n\\n// move minimum\\nfloat smin( float a, float b, float k )\\n{\\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\\n    return mix( b, a, h ) - k*h*(1.0-h);\\n}\\n\\nfloat sdSphere( vec3 p, float r ){\\n  return length(p)-r;\\n}\\n\\nfloat sdBox( vec3 p, vec3 b )\\n{\\n  vec3 q = abs(p) - b;\\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\\n}\\n\\nfloat rand(vec2 co){\\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\\n}\\n\\nvec2 sdf(vec3 p){\\n\\tfloat type = 0.;\\n\\tvec3 p1 = rotate(p,vec3(1.),time/5.);\\n\\tfloat s = 0.3 + 0.1*sin(time/3.) + 0.2*sin(time/6.) + 0.05*sin(time);\\n\\tfloat box = smin(sdBox(p1, vec3(s)), sdSphere(p,s), s);\\n\\tfloat realsphere = sdSphere(p1,0.3);\\n\\tfloat final = mix(box, realsphere,0.5 + 0.5*sin(time/3.));\\n\\t\\n\\n\\tfor(float i=0.;i<10.;i++){\\n\\t\\tfloat randOffset = rand(vec2(i,0.));\\n\\t\\tfloat progr = 1. - fract(time/3. + randOffset*3.);\\n\\t\\tvec3 pos = vec3(sin(randOffset*2.*PI),cos(randOffset*2.*PI),0.);\\n\\t\\tfloat gotoCenter = sdSphere(p - pos*progr, 0.1*sin(PI*progr));\\n\\t\\tfinal = smin(final,gotoCenter, 0.3);\\n\\t}\\n\\t\\n\\tfloat mouseSphere = sdSphere(p - vec3(mouse*resolution.zw*2.,0.),0.2 + 0.1*sin(time));\\n\\tif(mouseSphere<final) type = 1.;\\n\\treturn vec2(smin(final,mouseSphere,0.4), type);\\n}\\n\\nvec3 calcNormal( in vec3 p ){ // for function f(p)\\nconst float eps = 0.0001; // or some other value\\nconst vec2 h = vec2(eps,0);\\nreturn normalize( vec3(sdf(p+h.xyy).x - sdf(p-h.xyy).x,\\nsdf(p+h.yxy).x - sdf(p-h.yxy).x,\\nsdf(p+h.yyx).x - sdf(p-h.yyx).x ) );\\n}\\n\\nvoid main()\\t{\\n\\tfloat dist = length(vUv - vec2(0.5));\\n  vec3 bg = mix(vec3(0.3),vec3(0.0), dist);\\n\\tvec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);\\n\\tvec3 camPos = vec3(0.,0.,2.);\\n\\tvec3 ray = normalize(vec3((vUv - vec2(0.5))*resolution.zw,-1));\\n\\n\\tvec3 rayPos = camPos;\\n\\tfloat t = 0.;\\n\\tfloat tMax = 5.;\\n\\tfloat type = -1.;\\n\\tfor(int i=0;i<256;++i){\\n\\t\\tvec3 pos = camPos + t*ray;\\n\\t\\tfloat h = sdf(pos).x;\\n\\t\\ttype = sdf(pos).y;\\n\\t\\tif(h<0.0001 || t>tMax) break;\\n\\t\\tt+=h;\\n\\t}\\n\\n\\tvec3 color = bg;\\n\\tif(t<tMax){\\n\\t\\tvec3 pos = camPos + t*ray;\\n\\t\\tcolor = vec3(1.);\\n\\t\\tvec3 normal = calcNormal(pos);\\n\\t\\tcolor = normal;\\n\\t\\tfloat diff = dot(vec3(1.),normal);\\n\\t\\tvec2 matcapUV = getmatcap(ray,normal);\\n\\t\\tcolor = vec3(diff);\\n\\t\\tif(type<0.5){\\n\\t\\t\\tcolor = texture2D(matcap,matcapUV).rgb;\\n\\t\\t} else{\\n\\t\\t\\tcolor = texture2D(matcap1,matcapUV).rgb;\\n\\t\\t}\\n\\t\\t\\n\\n\\t\\tfloat fresnel = pow(1. + dot(ray,normal),3.);\\n\\t\\t// color = vec3(fresnel);\\n\\t\\tcolor = mix(color,bg,fresnel);\\n\\t}\\n\\t\\n\\tgl_FragColor = vec4(color,1.);\\n\\t// gl_FragColor = vec4(bg,1.);\\n}\";"},"sourceMaps":{"js":{"mappings":[{"name":"module","generated":{"line":1,"column":0},"source":"js/shader/fragment.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":6},"source":"js/shader/fragment.glsl","original":{"line":1,"column":6}},{"name":"exports","generated":{"line":1,"column":7},"source":"js/shader/fragment.glsl","original":{"line":1,"column":7}},{"generated":{"line":1,"column":14},"source":"js/shader/fragment.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":17},"source":"js/shader/fragment.glsl","original":{"line":1,"column":15}},{"generated":{"line":1,"column":3912},"source":"js/shader/fragment.glsl","original":{"line":1,"column":0}}],"sources":{"js/shader/fragment.glsl":"module.exports=\"#define GLSLIFY 1\\nuniform float time;\\nuniform float progress;\\nuniform vec2 mouse;\\nuniform sampler2D matcap,matcap1;\\nuniform vec4 resolution;\\nvarying vec2 vUv;\\n// varying vec3 vPosition;\\nfloat PI = 3.141592653589793238;\\n\\n// matcap formula\\nvec2 getmatcap(vec3 eye, vec3 normal) {\\n  vec3 reflected = reflect(eye, normal);\\n  float m = 2.8284271247461903 * sqrt( reflected.z+1.0 );\\n  return reflected.xy / m + 0.5;\\n}\\n\\n// rotation\\nmat4 rotationMatrix(vec3 axis, float angle) {\\n    axis = normalize(axis);\\n    float s = sin(angle);\\n    float c = cos(angle);\\n    float oc = 1.0 - c;\\n    \\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\\n                0.0,                                0.0,                                0.0,                                1.0);\\n}\\n\\nvec3 rotate(vec3 v, vec3 axis, float angle) {\\n\\tmat4 m = rotationMatrix(axis, angle);\\n\\treturn (m * vec4(v, 1.0)).xyz;\\n}\\n\\n// move minimum\\nfloat smin( float a, float b, float k )\\n{\\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\\n    return mix( b, a, h ) - k*h*(1.0-h);\\n}\\n\\nfloat sdSphere( vec3 p, float r ){\\n  return length(p)-r;\\n}\\n\\nfloat sdBox( vec3 p, vec3 b )\\n{\\n  vec3 q = abs(p) - b;\\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\\n}\\n\\nfloat rand(vec2 co){\\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\\n}\\n\\nvec2 sdf(vec3 p){\\n\\tfloat type = 0.;\\n\\tvec3 p1 = rotate(p,vec3(1.),time/5.);\\n\\tfloat s = 0.3 + 0.1*sin(time/3.) + 0.2*sin(time/6.) + 0.05*sin(time);\\n\\tfloat box = smin(sdBox(p1, vec3(s)), sdSphere(p,s), s);\\n\\tfloat realsphere = sdSphere(p1,0.3);\\n\\tfloat final = mix(box, realsphere,0.5 + 0.5*sin(time/3.));\\n\\t\\n\\n\\tfor(float i=0.;i<10.;i++){\\n\\t\\tfloat randOffset = rand(vec2(i,0.));\\n\\t\\tfloat progr = 1. - fract(time/3. + randOffset*3.);\\n\\t\\tvec3 pos = vec3(sin(randOffset*2.*PI),cos(randOffset*2.*PI),0.);\\n\\t\\tfloat gotoCenter = sdSphere(p - pos*progr, 0.1*sin(PI*progr));\\n\\t\\tfinal = smin(final,gotoCenter, 0.3);\\n\\t}\\n\\t\\n\\tfloat mouseSphere = sdSphere(p - vec3(mouse*resolution.zw*2.,0.),0.2 + 0.1*sin(time));\\n\\tif(mouseSphere<final) type = 1.;\\n\\treturn vec2(smin(final,mouseSphere,0.4), type);\\n}\\n\\nvec3 calcNormal( in vec3 p ){ // for function f(p)\\nconst float eps = 0.0001; // or some other value\\nconst vec2 h = vec2(eps,0);\\nreturn normalize( vec3(sdf(p+h.xyy).x - sdf(p-h.xyy).x,\\nsdf(p+h.yxy).x - sdf(p-h.yxy).x,\\nsdf(p+h.yyx).x - sdf(p-h.yyx).x ) );\\n}\\n\\nvoid main()\\t{\\n\\tfloat dist = length(vUv - vec2(0.5));\\n  vec3 bg = mix(vec3(0.3),vec3(0.0), dist);\\n\\tvec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);\\n\\tvec3 camPos = vec3(0.,0.,2.);\\n\\tvec3 ray = normalize(vec3((vUv - vec2(0.5))*resolution.zw,-1));\\n\\n\\tvec3 rayPos = camPos;\\n\\tfloat t = 0.;\\n\\tfloat tMax = 5.;\\n\\tfloat type = -1.;\\n\\tfor(int i=0;i<256;++i){\\n\\t\\tvec3 pos = camPos + t*ray;\\n\\t\\tfloat h = sdf(pos).x;\\n\\t\\ttype = sdf(pos).y;\\n\\t\\tif(h<0.0001 || t>tMax) break;\\n\\t\\tt+=h;\\n\\t}\\n\\n\\tvec3 color = bg;\\n\\tif(t<tMax){\\n\\t\\tvec3 pos = camPos + t*ray;\\n\\t\\tcolor = vec3(1.);\\n\\t\\tvec3 normal = calcNormal(pos);\\n\\t\\tcolor = normal;\\n\\t\\tfloat diff = dot(vec3(1.),normal);\\n\\t\\tvec2 matcapUV = getmatcap(ray,normal);\\n\\t\\tcolor = vec3(diff);\\n\\t\\tif(type<0.5){\\n\\t\\t\\tcolor = texture2D(matcap,matcapUV).rgb;\\n\\t\\t} else{\\n\\t\\t\\tcolor = texture2D(matcap1,matcapUV).rgb;\\n\\t\\t}\\n\\t\\t\\n\\n\\t\\tfloat fresnel = pow(1. + dot(ray,normal),3.);\\n\\t\\t// color = vec3(fresnel);\\n\\t\\tcolor = mix(color,bg,fresnel);\\n\\t}\\n\\t\\n\\tgl_FragColor = vec4(color,1.);\\n\\t// gl_FragColor = vec4(bg,1.);\\n}\";"},"lineCount":null}},"error":null,"hash":"db1da189bb9c03e32cd8622d66a1c55f","cacheData":{"env":{}}}